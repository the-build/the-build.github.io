---
title: '872. Leaf-Similar Trees'
description: 'Solve <872. Leaf-Similar Trees>'
date: '2024-01-28'
banner:
  src: ''
  alt: ''
  caption: ''
categories: 
  - 'Computer Science'
  - 'Coding'
keywords: 
  - 'Tree'
  - 'Depth-First Search'
  - 'Binary Tree'
---

<aside>

> ## ğŸ’¡ **Situation**

</aside>

1. There is two TreeNode. Collect had not been Nodeâ€™s val each TreeNode.
ë‘ íŠ¸ë¦¬ë…¸ë“œì— ëŒ€í•´ ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ ë°©í–¥ìœ¼ë¡œ ìì‹ì´ ì—†ëŠ” ë…¸ë“œë¥¼ ìˆ˜ì§‘í•œë‹¤.
2. ë‘ íŠ¸ë¦¬ë…¸ë“œì˜ ìì‹ì—…ëŠ” ë…¸ë“œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë¹„êµí•˜ì—¬ ìˆœì„œê°€ ê°™ìœ¼ë©´ True, ë‹¤ë¥´ë©´ False ë°˜í™˜í•œë‹¤.

<aside>


> ## ğŸ“‹**Task**

</aside>

- TreeNode ì— ëŒ€í•´ ì‘ìš©í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ì¡°ì‚¬
- 

<aside>

> ## ğŸ§‘â€ğŸ’» **Action**

</aside>

- ì¡°ì‚¬í•œ ë‚´ìš©

**`TreeNode`**ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ì¼ë°˜ì ìœ¼ë¡œ ì´ì§„ íŠ¸ë¦¬ì™€ ê´€ë ¨ëœ ì—¬ëŸ¬ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤. ì•„ë˜ëŠ” ëª‡ ê°€ì§€ ì‘ìš© ì˜ˆì œì™€ ë©”ì†Œë“œë“¤ì— ëŒ€í•œ ê°„ëµí•œ ì„¤ëª…ì…ë‹ˆë‹¤:

1. **íŠ¸ë¦¬ ìˆœíšŒ (Tree Traversal):** ì´ì§„ íŠ¸ë¦¬ë¥¼ ìˆœíšŒí•˜ë©´ì„œ ê° ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ëŠ” ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤. ëŒ€í‘œì ì¸ íŠ¸ë¦¬ ìˆœíšŒ ë°©ë²•ìœ¼ë¡œëŠ” ì „ìœ„ ìˆœíšŒ(preorder), ì¤‘ìœ„ ìˆœíšŒ(inorder), í›„ìœ„ ìˆœíšŒ(postorder)ê°€ ìˆìŠµë‹ˆë‹¤. ê°ê°ì˜ ìˆœíšŒ ë°©ë²•ì— ëŒ€í•œ ë©”ì†Œë“œë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    
    ```python
    def preorder_traversal(node):
        if node is not None:
            print(node.value)
            preorder_traversal(node.left)
            preorder_traversal(node.right)
    ```
    
2. **íŠ¸ë¦¬ ë†’ì´ êµ¬í•˜ê¸°:** íŠ¸ë¦¬ì˜ ë†’ì´ëŠ” ë£¨íŠ¸ ë…¸ë“œì—ì„œ ê°€ì¥ ê¹Šì€ ë¦¬í”„ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. íŠ¸ë¦¬ ë†’ì´ë¥¼ êµ¬í•˜ëŠ” ë©”ì†Œë“œë¥¼ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    
    ```python
    def tree_height(node):
        if node is None:
            return 0
        else:
            left_height = tree_height(node.left)
            right_height = tree_height(node.right)
            return max(left_height, right_height) + 1
    ```
    
3. **ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (BST) ê²€ìƒ‰:** ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ íŠ¹ì • ê°’ì„ ê²€ìƒ‰í•˜ëŠ” ë©”ì†Œë“œë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë•Œ, ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ íŠ¹ì„±ì„ í™œìš©í•˜ì—¬ ë¶ˆí•„ìš”í•œ íƒìƒ‰ì„ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    
    ```python
    def search_bst(node, target):
        if node is None or node.value == target:
            return node
        if target < node.value:
            return search_bst(node.left, target)
        else:
            return search_bst(node.right, target)
    ```
    
4. **íŠ¸ë¦¬ ë…¸ë“œ ê°œìˆ˜ ì„¸ê¸°:** íŠ¸ë¦¬ì— ìˆëŠ” ì „ì²´ ë…¸ë“œì˜ ê°œìˆ˜ë¥¼ ì„¸ëŠ” ë©”ì†Œë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    
    ```python
    def count_nodes(node):
        if node is None:
            return 0
        else:
            return 1 + count_nodes(node.left) + count_nodes(node.right)
    ```
    

ì´ì™¸ì—ë„ ì´ì§„ íŠ¸ë¦¬ì™€ ê´€ë ¨ëœ ë‹¤ì–‘í•œ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‹¤ì œ ì‘ìš©ì— ë”°ë¼ì„œëŠ” íŠ¹ì •í•œ ì‘ì—…ì— í•„ìš”í•œ ë©”ì†Œë“œë¥¼ ì¶”ê°€ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- ì½”ë”©

```python
class Solution:
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        leaf1 = []
        leaf2 = []

        #root1 is left node
        #root2 is right node
        self.findLeaf(root1, leaf1)
        self.findLeaf(root2, leaf2)

        if leaf1 == leaf2:
            return True
        else:
            return False

    def findLeaf(self, node: TreeNode, leaves: List[int] = []):
        if node.left is None and node.right is None:
            leaves.append(node.val)
            return

        if node.left is not None:
            self.findLeaf(node.left, leaves)
        if node.right is not None:
            self.findLeaf(node.right, leaves)
```

<aside>

> ## ğŸ—½ **Result**

</aside>

- My answer

![Untitled](../../../images/s-CS/coding/leetcode_872_1.png)

- resummit

![Untitled](../../../images/s-CS/coding/leetcode_872_1.png)